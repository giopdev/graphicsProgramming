     11045:	find library=libglfw.so.3 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libglfw.so.3
     11045:	
     11045:	find library=libvulkan.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libvulkan.so.1
     11045:	
     11045:	find library=libX11.so.6 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libX11.so.6
     11045:	
     11045:	find library=libXxf86vm.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libXxf86vm.so.1
     11045:	
     11045:	find library=libXrandr.so.2 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libXrandr.so.2
     11045:	
     11045:	find library=libXi.so.6 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libXi.so.6
     11045:	
     11045:	find library=libstdc++.so.6 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libstdc++.so.6
     11045:	
     11045:	find library=libm.so.6 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libm.so.6
     11045:	
     11045:	find library=libgcc_s.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libgcc_s.so.1
     11045:	
     11045:	find library=libc.so.6 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libc.so.6
     11045:	
     11045:	find library=libxcb.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libxcb.so.1
     11045:	
     11045:	find library=libXext.so.6 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libXext.so.6
     11045:	
     11045:	find library=libXrender.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libXrender.so.1
     11045:	
     11045:	find library=libXau.so.6 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libXau.so.6
     11045:	
     11045:	find library=libXdmcp.so.6 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libXdmcp.so.6
     11045:	
     11045:	
     11045:	calling init: /lib64/ld-linux-x86-64.so.2
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libc.so.6
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libXdmcp.so.6
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libXau.so.6
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libxcb.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libX11.so.6
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libXrender.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libXext.so.6
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libgcc_s.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libm.so.6
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libstdc++.so.6
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libXi.so.6
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libXrandr.so.2
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libXxf86vm.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libvulkan.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libglfw.so.3
     11045:	
     11045:	
     11045:	initialize program: ./main.bin
     11045:	
     11045:	
     11045:	transferring control: ./main.bin
     11045:	
     11045:	find library=libXcursor.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libXcursor.so.1
     11045:	
     11045:	find library=libXfixes.so.3 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libXfixes.so.3
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libXfixes.so.3
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libXcursor.so.1
     11045:	
     11045:	find library=libXinerama.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libXinerama.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libXinerama.so.1
     11045:	
     11045:	find library=libX11-xcb.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libX11-xcb.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libX11-xcb.so.1
     11045:	
     11045:	find library=libdrm.so.2 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libdrm.so.2
     11045:	
     11045:	find library=libz.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libz.so.1
     11045:	
     11045:	find library=libzstd.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libzstd.so.1
     11045:	
     11045:	find library=libxcb-dri3.so.0 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libxcb-dri3.so.0
     11045:	
     11045:	find library=libxcb-present.so.0 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libxcb-present.so.0
     11045:	
     11045:	find library=libxcb-xfixes.so.0 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libxcb-xfixes.so.0
     11045:	
     11045:	find library=libxcb-sync.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libxcb-sync.so.1
     11045:	
     11045:	find library=libxcb-randr.so.0 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libxcb-randr.so.0
     11045:	
     11045:	find library=libxcb-shm.so.0 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libxcb-shm.so.0
     11045:	
     11045:	find library=libxshmfence.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libxshmfence.so.1
     11045:	
     11045:	find library=libxcb-keysyms.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libxcb-keysyms.so.1
     11045:	
     11045:	find library=libwayland-client.so.0 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libwayland-client.so.0
     11045:	
     11045:	find library=libudev.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libudev.so.1
     11045:	
     11045:	find library=libexpat.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libexpat.so.1
     11045:	
     11045:	find library=libSPIRV-Tools.so [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libSPIRV-Tools.so
     11045:	
     11045:	find library=libffi.so.8 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libffi.so.8
     11045:	
     11045:	find library=libcap.so.2 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libcap.so.2
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libcap.so.2
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libffi.so.8
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libSPIRV-Tools.so
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libexpat.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libudev.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libwayland-client.so.0
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libxcb-keysyms.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libxshmfence.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libxcb-shm.so.0
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libxcb-randr.so.0
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libxcb-sync.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libxcb-xfixes.so.0
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libxcb-present.so.0
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libxcb-dri3.so.0
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libzstd.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libz.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libdrm.so.2
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libvulkan_intel.so
     11045:	
     11045:	find library=libLLVM.so.19.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libLLVM.so.19.1
     11045:	
     11045:	find library=libelf.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libelf.so.1
     11045:	
     11045:	find library=libdrm_amdgpu.so.1 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libdrm_amdgpu.so.1
     11045:	
     11045:	find library=libedit.so.0 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libedit.so.0
     11045:	
     11045:	find library=libxml2.so.16 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libxml2.so.16
     11045:	
     11045:	find library=libncursesw.so.6 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libncursesw.so.6
     11045:	
     11045:	find library=liblzma.so.5 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/liblzma.so.5
     11045:	
     11045:	find library=libicuuc.so.76 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libicuuc.so.76
     11045:	
     11045:	find library=libicudata.so.76 [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libicudata.so.76
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libicudata.so.76
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libicuuc.so.76
     11045:	
     11045:	
     11045:	calling init: /usr/lib/liblzma.so.5
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libncursesw.so.6
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libxml2.so.16
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libedit.so.0
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libdrm_amdgpu.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libelf.so.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libLLVM.so.19.1
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libvulkan_radeon.so
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libvulkan_intel_hasvk.so
     11045:	
validation layer: Searching for ICD drivers named /usr/lib/libvulkan_intel.so
validation layer: Searching for ICD drivers named /usr/lib32/libvulkan_radeon.so
validation layer: Searching for ICD drivers named /usr/lib/libvulkan_radeon.so
validation layer: Searching for ICD drivers named /usr/lib/libvulkan_intel_hasvk.so
     11045:	find library=libVkLayer_khronos_validation.so [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libVkLayer_khronos_validation.so
     11045:	
     11045:	find library=libSPIRV-Tools-opt.so [0]; searching
     11045:	 search cache=/etc/ld.so.cache
     11045:	  trying file=/usr/lib/libSPIRV-Tools-opt.so
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libSPIRV-Tools-opt.so
     11045:	
     11045:	
     11045:	calling init: /usr/lib/libVkLayer_khronos_validation.so
     11045:	
validation layer: Loading layer library libVkLayer_khronos_validation.so
validation layer: Copying old device 0 into new device 0
validation layer: Copying old device 0 into new device 0
validation layer: Copying old device 0 into new device 0
     11045:	
     11045:	calling fini: /usr/lib/libvulkan_intel_hasvk.so [0]
     11045:	
     11045:	
     11045:	calling fini: /usr/lib/libvulkan_intel.so [0]
     11045:	
validation layer: vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x1a000000001a) is being signaled by VkQueue 0x5dfd1edaf4e0, but it may still be in use by VkSwapchainKHR 0x1c000000001c.
Here are the most recently acquired image indices: [0], 1, 2.
(brackets mark the last use of VkSemaphore 0x1a000000001a in a presentation operation)
Swapchain image 0 was presented but was not re-acquired, so VkSemaphore 0x1a000000001a may still be in use and cannot be safely reused with image index 2.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_EXT_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
validation layer: vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x170000000017) is being signaled by VkQueue 0x5dfd1edaf4e0, but it may still be in use by VkSwapchainKHR 0x1c000000001c.
Here are the most recently acquired image indices: 0, [1], 2, 3.
(brackets mark the last use of VkSemaphore 0x170000000017 in a presentation operation)
Swapchain image 1 was presented but was not re-acquired, so VkSemaphore 0x170000000017 may still be in use and cannot be safely reused with image index 3.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_EXT_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
validation layer: vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x1a000000001a) is being signaled by VkQueue 0x5dfd1edaf4e0, but it may still be in use by VkSwapchainKHR 0x1c000000001c.
Here are the most recently acquired image indices: 3, 0, 1, 2, 3, [0], 1, 3.
(brackets mark the last use of VkSemaphore 0x1a000000001a in a presentation operation)
Swapchain image 0 was presented but was not re-acquired, so VkSemaphore 0x1a000000001a may still be in use and cannot be safely reused with image index 3.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_EXT_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
validation layer: vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x170000000017) is being signaled by VkQueue 0x5dfd1edaf4e0, but it may still be in use by VkSwapchainKHR 0x1c000000001c.
Here are the most recently acquired image indices: 3, 2, 0, 1, 3, [2], 0, 3.
(brackets mark the last use of VkSemaphore 0x170000000017 in a presentation operation)
Swapchain image 2 was presented but was not re-acquired, so VkSemaphore 0x170000000017 may still be in use and cannot be safely reused with image index 3.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_EXT_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
validation layer: vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x1a000000001a) is being signaled by VkQueue 0x5dfd1edaf4e0, but it may still be in use by VkSwapchainKHR 0x1c000000001c.
Here are the most recently acquired image indices: 1, 0, 3, 2, 1, [0], 3, 1.
(brackets mark the last use of VkSemaphore 0x1a000000001a in a presentation operation)
Swapchain image 0 was presented but was not re-acquired, so VkSemaphore 0x1a000000001a may still be in use and cannot be safely reused with image index 1.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_EXT_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
validation layer: vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x170000000017) is being signaled by VkQueue 0x5dfd1edaf4e0, but it may still be in use by VkSwapchainKHR 0x1c000000001c.
Here are the most recently acquired image indices: 1, 2, 0, 3, 1, [2], 0, 1.
(brackets mark the last use of VkSemaphore 0x170000000017 in a presentation operation)
Swapchain image 2 was presented but was not re-acquired, so VkSemaphore 0x170000000017 may still be in use and cannot be safely reused with image index 1.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_EXT_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
validation layer: vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x170000000017) is being signaled by VkQueue 0x5dfd1edaf4e0, but it may still be in use by VkSwapchainKHR 0x1c000000001c.
Here are the most recently acquired image indices: 3, 2, 0, 1, 3, [2], 0, 3.
(brackets mark the last use of VkSemaphore 0x170000000017 in a presentation operation)
Swapchain image 2 was presented but was not re-acquired, so VkSemaphore 0x170000000017 may still be in use and cannot be safely reused with image index 3.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_EXT_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
validation layer: vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x170000000017) is being signaled by VkQueue 0x5dfd1edaf4e0, but it may still be in use by VkSwapchainKHR 0x1c000000001c.
Here are the most recently acquired image indices: 1, 2, 0, 3, 1, [2], 0, 1.
(brackets mark the last use of VkSemaphore 0x170000000017 in a presentation operation)
Swapchain image 2 was presented but was not re-acquired, so VkSemaphore 0x170000000017 may still be in use and cannot be safely reused with image index 1.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_EXT_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
validation layer: vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x170000000017) is being signaled by VkQueue 0x5dfd1edaf4e0, but it may still be in use by VkSwapchainKHR 0x1c000000001c.
Here are the most recently acquired image indices: 0, 1, 3, 2, 0, [1], 3, 0.
(brackets mark the last use of VkSemaphore 0x170000000017 in a presentation operation)
Swapchain image 1 was presented but was not re-acquired, so VkSemaphore 0x170000000017 may still be in use and cannot be safely reused with image index 0.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_EXT_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
validation layer: (Warning - This VUID has now been reported 10 times, which is the duplicated_message_limit value, this will be the last time reporting it).
vkQueueSubmit(): pSubmits[0].pSignalSemaphores[0] (VkSemaphore 0x1a000000001a) is being signaled by VkQueue 0x5dfd1edaf4e0, but it may still be in use by VkSwapchainKHR 0x1c000000001c.
Here are the most recently acquired image indices: 1, 3, 0, 2, 1, [3], 0, 1.
(brackets mark the last use of VkSemaphore 0x1a000000001a in a presentation operation)
Swapchain image 3 was presented but was not re-acquired, so VkSemaphore 0x1a000000001a may still be in use and cannot be safely reused with image index 1.
Vulkan insight: One solution is to assign each image its own semaphore. Here are some common methods to ensure that a semaphore passed to vkQueuePresentKHR is not in use and can be safely reused:
	a) Use a separate semaphore per swapchain image. Index these semaphores using the index of the acquired image.
	b) Consider the VK_EXT_swapchain_maintenance1 extension. It allows using a VkFence with the presentation operation.
The Vulkan spec states: Each binary semaphore element of the pSignalSemaphores member of any element of pSubmits must be unsignaled when the semaphore signal operation it defines is executed on the device (https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#VUID-vkQueueSubmit-pSignalSemaphores-00067)
